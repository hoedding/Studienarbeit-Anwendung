
\subsection{Protokoll}
Um die LEDs später von einer App aus ansprechen zu können, soll ein auf Strings basierendes Protokoll implementiert werden. Dieses wird in TCP-Paketen übertragen. Hierfür muss als erstes festgelegt werden, welche Informationen übertragen werden sollen: \\
\begin{itemize}
\item Authentifizierung\\
Übertragung eines Passworts. Dieses ist als Hashwert im System gespeichert und kann so überprüft werden. Es wird der SHA-224-Algorithmus eingesetzt.
\item Control\\
Unterscheidung zwischen:\\
	- X00: Alle LEDs ausschalten\\
	- X01: Eine LED anschalten\\
	- X02: LED-Bereich anschalten\\
	- X03: Effekt für eine LED\\
	- X04: Effekt für LED-Bereich\\
	- X05: Effektcode \\\\
Abhängig von diesem Feld werden die nachfolgenden Werte behandelt. 
\item LED-Nummer\\
Falls nur eine LED angesprochen werden soll (Control = X00), so wird hier die Nummer angegeben. Ob sie im gültigen Range liegt wird intern überprüft.
\item Bereich Start\\
Wenn mehrere LEDs gesteuert werden sollen (Control = X01), so wird hier der Beginn des Bereichs angegeben.
\item Bereich Ende\\
Und hier das Ende des Bereichs. 
\item Rot\\
Farbwert Rot 0-255
\item Grün\\
Farbwert Grün 0-255
\item Blau\\
Farbwert Blau 0-255
\item Effekt\\
Es können verschiedene LEDs mit Effekten belegt werden, wie zum Beispiel Aufblitzen oder zeitgesteuertes Ausschalten.
\item Effektcode\\
Hinterlegte, fest programmierte Effekte, zum Beispiel alle LEDs anschalten in weis mit höchster Leuchstärke.
\item Hash\\
Überprüfung ob die Übertragung erfolgreich war, mittels eines Hashwertes. Es wird der SHA-224-Algorithmus eingesetzt.
\end{itemize}
\textbf{Übertragungsbeispiel:}\\
		Protokoll: 	
\begin{lstlisting}[caption = Beispielübertragung des Protokolls, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b]
auth:control:ledNo:rangeStart:rangeEnd:red:green:blue:effect:effectcode:hash
pass:X01:0:0:49:255:255:255:0:0:xx
\end{lstlisting}
Dies w\ürde die LEDs 0 bis 49 einschalten (Farbe weis 255,255,255). Anstelle der XX würde der Hashwert der gesamten Übertragung gesendet. 
\subsection{Framework}
Twisted: https://twistedmatrix.com \\
Es wird das Twisted Matrix Framework eingesetzt. Twisted ist eine in Python geschriebene  event-getriebene Netzwerkengine. Die meisten gängigen Protokolle wie TCP, IMAP, SSHv3 und viele mehr werden unterstützt. Somit bietet Twisted die ideale Möglichkeit einen eigenen simplen Server zu implementieren. \\\\
\textbf{Event-Getrieben (event-based):} Die Serveranwendung befindet sich in einer Schleife und wartet auf ein Event. Dieses Event ist in diesem Fall der Connect eines Clients zum Server. Für jeden Connect wird eine neue Instanz angelegt, in welcher empfangene Daten bearbeitet werden können. Die Daten werden als String ausgewertet, somit wird ein string-basiertes Protokoll implementiert. \cite{eventbased}

\subsection{Testcode}
\begin{lstlisting}[caption =Testcode Echoserver mit Twisted Framework, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b, numbers = left]
#!/usr/bin/env python
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

from twisted.internet.protocol import Protocol, Factory
from twisted.internet import reactor

### Protocol Implementation

# This is just about the simplest possible protocol
class Echo(Protocol):
	def dataReceived(self, data):
		self.transport.write(data)


	def main():
		f = Factory()
		f.protocol = Echo
		reactor.listenTCP(8000, f)
		reactor.run()

if __name__ == '__main__':
main()
\end{lstlisting}

//TODO ERKLÄRUNG

\subsection{Implementierung}
Im Folgenden wird die Implementierung des Servers näher erläutert. \\\\
	
	// TODO CODE des Servers

\subsection{Klassen und ihre Funktionen}
// TODO
\subsection{Hashfunktion}
Es wird zu zweierlei Zwecken eine Hashfunktion eingesetzt. Zum einen um die Korrektheit der Übertragung zu überprüfen und zum Anderen um ein Passwort zur Authentifizierung verwenden zu können. Dieses wird als Wort übertragen, auf dem Server aber nur als Hash-Wert abgespeichert. Falls es also jemand schafft die Konfirgurationsdatei abzugreifen, so ist der Passworthash nichts wert. 

\section{Verschlüsselung}
\subsection{SSL vs. TLS}
SSL (Secure Sockets Layer) und TLS (Transport Layer Security) sind Protokolle, die Verschlüsselung und Authentifizierung zwischen zwei Kommunikationspartnern bieten. Die beiden Begriffe SSL und TLS werden umgangssprachlich oft als zwei verschiedene Techniken dargestellt, obwohl TLS nur eine Weiterentwicklung von SSL ist. SSL v3 ist die Basis von TLS 1.0. \\
Aufgrund des Alters und einiger Sicherheitslücken wird SSL als unsicher angesehen und soll nicht mehr verwendet werden. Die aktuellste gefundene Lücke ist POODLE, welche das Auslesen von Informationen aus einer verschlüsselten Übertragung erlaubt. Die Weiterentwicklungen TLS 1.1 und 1.2 sind deutlich sicherer und beheben einige Sicherheitslücken. So schützt die richtige Implementierung von TLS 1.2 auch vor den BEAST Angriffsmethoden.\\
Eine Variante von TLS ist das sogenannte STARTTLS, bei dem zuerst ein unsicheres 'hello' an den Server gesendet wird. Falls im Anschluss eine Verbindung erfolgreich Zustande kommt, wird zur sicheren Übertragung gewechselt. \\
Wenn ein Server implementiert wird, so muss er alle Techniken unterstützen, beim Client kann der Entwickler selbst entscheiden. Ein Entwickler sollte immer die höchst mögliche Verschlüsselungstechnik einsetzen. \\

\subsection{Vor- und Nachteile TLS}
Da TLS auf der Transportschicht aufsetzt kann jedes höhere Protokoll darüber übertragen werden, somit ist die Verschlüsselung unabhängig von der genutzten Anwendung. \\
	Der größte Nachteil besteht darin, dass der Verbindungsaufbau serverseitig sehr rechenintensiv ist. Die Verschlüsselung selbst nimmt, abhängig vom Algorithmus, nur noch wenige Rechenleistung in Anspruch. \\

\subsection{TLS Handshake}
1. Client Hello\\
Übertragung von Verschlüsselungsinformationen vom Client an den Server, wie TLS Version oder Verschlüsselungsmöglichkeiten\\
2. Server Hello \\
Server sendet seine Informationen und legt Verschlüsselung fest. \\
3. Server Key Exchange\\
Server sendet seine Identität in Form seines Zertifikats. \\
4. Client Key Exchange\\
Client legt seinen Pre-Shared-Key fest und überträgt ihn verschlüsselt mit dem public Key des Servers.\\
5. Change Cipher Spec\\
Aus dem PSK wird ein Master-Secret generiert, mit welchem die folgenden Übertragung abgesichert wird. \\
6. Application Data\\
Übertragung der Daten. \\

\subsection{Zertifikat und Key}
Auf dem Raspberry Pi ist OpenSSL in der neuesten Version installiert. Es wird ein selbst-signiertes Zertifikat im 2048 Bit Key erzeugt.\\
1. Private Key erzeugen\\
openssl genrsa -des3 -out server.key 2048\\
2. Certificate Signing Request\\
openssl req -new -key server.key -out server.csr\\
3. Self Signed Certificate\\
Bei einem öffentlichen Server sollte das Zertifikat bei einer CA (Certificate Authority) signiert werden. \\
openssl x509 -req -days 1865 -in server.csr -signkey server.key -out server.crt

\subsection{Beispielcode STARTTLS Server}
An dieser Stelle ist der Beispielcode von Twisted am besten verständlich\\
(Quelle: https://twistedmatrix.com/documents/12.3.0/core/howto/ssl.html)\\
\begin{lstlisting}[caption =Testcode Echoserver mit Twisted Framework, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b, numbers = left]
from OpenSSL import SSL
from twisted.internet import reactor, ssl
from twisted.internet.protocol import ServerFactory
from twisted.protocols.basic import LineReceiver

class TLSServer(LineReceiver):
    def lineReceived(self, line):
        print "received: " + line

        if line == "STARTTLS":
            print "-- Switching to TLS"
            self.sendLine('READY')
            ctx = ServerTLSContext(
                privateKeyFileName='keys/server.key',
                certificateFileName='keys/server.crt',
                )
            self.transport.startTLS(ctx, self.factory)


class ServerTLSContext(ssl.DefaultOpenSSLContextFactory):
    def __init__(self, *args, **kw):
        kw['sslmethod'] = SSL.TLSv1_METHOD
        ssl.DefaultOpenSSLContextFactory.__init__(self, *args, **kw)

if __name__ == '__main__':
    factory = ServerFactory()
    factory.protocol = TLSServer
    reactor.listenTCP(8000, factory)
    reactor.run()
\end{lstlisting}
Es ist gut zu erkennen, dass die Übertragung nur ausgewertet wird, wenn das Stichwort "STARTTLS" am Anfang der Übertragung enthalten ist. Daraufhin wird mit "READY" geantwortet um dem Client zu signalisieren, dass jetzt der TLS Handshake begonnen werden kann. Im nächsten Schritt läd der Server sein Zertifikat und seinen Key. \\
In der Initmethode der Klasse ServerTLSContext können die Verschlüsselungsdetails festgelegt werden. Im obigen Beispiel wird hier zum Beospiel die TLS Version definiert.  \\

\subsection{Wireshark Trace}
Im folgenden ist ein Trace eines TLS Handshakes zwischen einem Client und dem implementierten Server auf dem Raspberry Pi zu sehen. // TODO beschreibung
