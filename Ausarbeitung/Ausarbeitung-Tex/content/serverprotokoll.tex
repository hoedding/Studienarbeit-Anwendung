
\subsection{Protokoll}
Um die LEDs später von einer App aus ansprechen zu können, soll ein auf Strings basierendes Protokoll implementiert werden. Dieses wird in TCP-Paketen übertragen. Hierfür muss als erstes festgelegt werden, welche Informationen übertragen werden sollen: \\
\begin{itemize}
\item Authentifizierung\\
Übertragung eines Passworts. Dieses ist als Hashwert im System gespeichert und kann so überprüft werden. Es wird der SHA-224-Algorithmus eingesetzt.
\item Control\\
Unterscheidung zwischen:\\
	- X00: Alle LEDs ausschalten\\
	- X01: Eine LED anschalten\\
	- X02: LED-Bereich anschalten\\
	- X03: Effekte\\
	- X04: Modus des Systems verändern\\\\
Abhängig von diesem Feld werden die nachfolgenden Werte behandelt. 
\item LED-Nummer\\
Falls nur eine LED angesprochen werden soll (Control = X00), so wird hier die Nummer angegeben. Ob sie im gültigen Range liegt wird intern überprüft.
\item Bereich Start\\
Wenn mehrere LEDs gesteuert werden sollen (Control = X01), so wird hier der Beginn des Bereichs angegeben.
\item Bereich Ende\\
Und hier das Ende des Bereichs. 
\item Rot\\
Farbwert Rot 0-255
\item Grün\\
Farbwert Grün 0-255
\item Blau\\
Farbwert Blau 0-255
\item Modus\\
An dieser Stelle werden die verschiedenen Modi des Systems dargestellt.
\item Effektcode\\
Hinterlegte, fest programmierte Effekte, zum Beispiel alle LEDs anschalten in weis mit höchster Leuchstärke.
\item Hash\\
Überprüfung ob die Übertragung erfolgreich war, mittels eines Hashwertes. Es wird der SHA-224-Algorithmus eingesetzt.
\end{itemize}
\textbf{Übertragungsbeispiel:}\\
		Protokoll: 	
\begin{lstlisting}[caption = Beispielübertragung des Protokolls, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b]
auth:control:ledNo:rangeStart:rangeEnd:red:green:blue:modus:effectcode:hash
pass:X01:0:0:49:255:255:255:0:0:xx
\end{lstlisting}
Dies w\ürde die LEDs 0 bis 49 einschalten (Farbe weis 255,255,255). Anstelle der XX würde der Hashwert der gesamten Übertragung gesendet. 
\subsection{Framework}
Twisted: https://twistedmatrix.com \\
Es wird das Twisted Matrix Framework eingesetzt. Twisted ist eine in Python geschriebene  event-getriebene Netzwerkengine. Die meisten gängigen Protokolle wie TCP, IMAP, SSHv3 und viele mehr werden unterstützt. Somit bietet Twisted die ideale Möglichkeit einen eigenen simplen Server zu implementieren. \\\\
\textbf{Event-Getrieben (event-based):} Die Serveranwendung befindet sich in einer Schleife und wartet auf ein Event. Dieses Event ist in diesem Fall der Connect eines Clients zum Server. Für jeden Connect wird eine neue Instanz angelegt, in welcher empfangene Daten bearbeitet werden können. Die Daten werden als String ausgewertet, somit wird ein string-basiertes Protokoll implementiert. \cite{eventbased}

\subsection{Testcode}
Im folgenden Beispiel wird ein Beispiel von Twisted Matrix gezeigt. Es implementiert ein sehr einfaches Protokoll, welches alle empfangenen Daten wieder zurück sendet. Das Protokoll reagiert auf Events und bearbeitet sie, sobald sie empfangen wurden. 
\begin{itemize}
\item connectionMade(self): Erstkontakt, wenn Verbindung hergestellt
\item dataReceived(self, data): Daten wurden empfangen
\item connectionLost(self, reason): Verbindung wurde unterbrochen
\end{itemize}
\begin{lstlisting}[caption =Testcode Echoserver mit Twisted Framework, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b, numbers = left]
#!/usr/bin/env python
# Copyright (c) Twisted Matrix Laboratories.
# See LICENSE for details.

from twisted.internet.protocol import Protocol, Factory
from twisted.internet import reactor

### Protocol Implementation

# This is just about the simplest possible protocol
class Echo(Protocol):
	def dataReceived(self, data):
		self.transport.write(data)


	def main():
		f = Factory()
		f.protocol = Echo
		reactor.listenTCP(8000, f)
		reactor.run()

if __name__ == '__main__':
main()
\end{lstlisting}




\subsection{Implementierung}
Der Server wird in einem neuen Thread gestartet, damit er unabhängig von allem anderen arbeiten kann. Zusätzich wird ihm eine Referenz auf die Center-Klasse übergeben. Somit kann er direkt auf die empfangenen Daten reagieren. Es wird nur eine Verbindung zum Server erlaubt. Falls sich ein weiterer Client verbinden will, wird die Verbindung direkt beendet.\\
Aufgrund der Implementierung von STARTTLS erwartet der Server als erste Übertragung das Stichwort "STARTTLS", dieses quitiert er mit "READY". Daraufhin initialisiert er die TLS-Verbindung. Details zur Übertragung mit TLS finden sie unter dem Punkt X.X Verschlüsselung. \\
Die nächste Übertragung kann Daten zur Steuerung, in Form des in X.X erläuterten Protokolls enthalten. Anhand der ":" werden die empfangenen Daten gesplittet und in ein Array abgelegt. Zur besseren Verständlichkeit werden die Werte in einzelne Variablen gespeichert. \\
Im Anschluss wird das Übertragene Passwort und die Korrektheit der Daten überprüft. Falls beides Korrekt ist, so werden die Daten anhand ihres Control-Feldes ausgewertet. \\
Bevor tatsächlich LEDs angesteuert werden, wird überprüft ob die Farbwert im gültigen Bereich (0-255) liegen und ob die Angabe der LED-Nummer korrekt ist.\\
	
\begin{lstlisting}[caption =Implementierung des SSL Servers, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b, numbers = left]
#!/usr/bin/python
# -*- coding: utf-8 -*-
############################
# Author: Timo Höting       		           #
# Mail: mail[at]timohoeting.de  		       #
############################
import sys
import threading
import hashlib
from ConfigReader import *
from OpenSSL import SSL
from twisted.internet import reactor, ssl
from twisted.internet.protocol import ServerFactory
from twisted.protocols.basic import LineReceiver

class TLSServer(LineReceiver):
    def lineReceived(self, line):
        print "received: " + line

        if line == "STARTTLS":
            print "-- Switching to TLS"
            self.sendLine('READY')
            ctx = ServerTLSContext(
                privateKeyFileName='./certs/server.key',
                certificateFileName='./certs/server.crt',
                )
            self.transport.startTLS(ctx, self.factory)
            connections.append(self)
        else:
            a = line.split(':')
            print a
            if len(a) > 1:
                auth = 		a[0]
                control = 	a[1]
                ledNo = 	a[2]
                rangeStart = a[3]
                rangeEnd = 	a[4]
                red = 		a[5]
                green = 	a[6]
                blue = 		a[7]
                modus = 	a[8]
                effectcode = a[9]
                hashv = a[10]
                data = auth + control + ledNo + rangeStart + rangeEnd + red + green + blue + modus + effectcode
                data = data.rstrip('\n')
                data = data.rstrip('\r')
                if (self.checkAuthentification(auth) & self.checkTransmissionData(data, hashv)):
                    if control == 'X00':
                        ## Alle LEDs ausschalten
                        center.clearPixel()
                    elif control == 'X01':
                        ## Eine LED anschalten
                        self.lightUpOneLED(int(ledNo), int(red), int(green), int(blue))
                    elif control == 'X02':
                        ## LED Bereich anschalten
                        self.lightUpLEDRange(int(rangeStart), int(rangeEnd), int(red), int(green), int(blue))
                    elif control == 'X03':
                        ## Effekt alle LEDs
                        self.effectLED(effectcode)
                    elif control == 'X04':
                        ## Modus des Systems
                        self.changeModus(int(modus))
                else:
                    print center.writeLog('Übertragung fehlerhaft')

    def changeModus(self, modus):
        center.setModus(modus)


    def lightUpOneLED(self, ledNo, red, green, blue):
        # Eine einzelne LED mit den o.g. RGB-Werten dauerhaft anschalten
        a = self.checkColorRange(red)
        b = self.checkColorRange(green)
        c = self.checkColorRange(blue)
        d = self.checkRange(ledNo)
        if ( a & b & c & d):
            center.lightUpOneLED(ledNo, red, green, blue)

    def lightUpLEDRange(self, rangeStart, rangeEnd, red, green, blue):
        # Einen Bereich von LEDs mit den o.g. RGB-Werten
        # dauerhaft einschalten
        # Bereich muss ueberprueft werden mit checkRange()
        a = self.checkColorRange(red)
        b = self.checkColorRange(green)
        c = self.checkColorRange(blue)
        d = self.checkRange(rangeStart)
        e = self.checkRange(rangeEnd)
        if ( a & b & c & d & e):
            center.rangePixel(rangeStart, rangeEnd, red, green, blue)

    def effectLED(self, code):
            # Effekte auf einer LED aktivieren
            center.effectLED(code)

    def checkRange(self, ledNo):
        # Ueberprueft ob die uebergeben LED-Nummer ueberhaupt im
        # gueltigen Bereich liegt
        # Es wird der Eintrag 'number' aus dem Config-File geladen
        reader = ConfigReader()
        number = int(reader.getNumberOfLED())
        if ( ledNo >= 0 & ledNo < number):
            return True
        else:
            return False

    def checkColorRange(self, color):
        # Überprüfung ob Farbwert im gültigen Bereich liegt
        if (color >= 0 & color <= 255):
            return True
        return False

    def checkAuthentification(self, auth):
        # Authentifizierung überprüfen
        # Eingabewert ist das Passwort aus der Übertragung
        # Dieses wird gehasht und mit dem in der Konfiguration gespeicherten
        # Hashwert verglichen
        reader = ConfigReader()
        hashv = reader.getHashPass()
        pw = hashlib.sha224(auth).hexdigest()
        if ( pw == hashv ):
            return True
        return False

    def checkTransmissionData(self, data, check):
        # Korrektheit der Übertragung mittels Hashvergleich feststellen
        # Eingabewert sind die gesamten Daten der Übertragung
        hashdata = hashlib.sha224(data).hexdigest()
        check = check.rstrip('\n')
        check = check.rstrip('\r')
        if ( hashdata == check ):
            return True
        # Für Testübertragung return immer True
        return True

    def sendMessage(self, message):
        self.sendLine(message)

class ServerTLSContext(ssl.DefaultOpenSSLContextFactory):
    def __init__(self, *args, **kw):
        kw['sslmethod'] = SSL.TLSv1_METHOD
        ssl.DefaultOpenSSLContextFactory.__init__(self, *args, **kw)

class StartLightServer(threading.Thread):
    def __init__(self, c):
        threading.Thread.__init__(self)
        global center
        center = c

    def run(self):
        global factory
        factory = ServerFactory()
        factory.protocol = TLSServer
        reactor.listenTCP(7005, factory)
        global connections
        connections = []
        reactor.run(installSignalHandlers=False)

    def pushNotification(self, message):
        # Funktioniert nicht
        for c in connections:
            c.sendLine('con con con')

\end{lstlisting}


\subsection{Hashfunktion}
Es wird zu zweierlei Zwecken eine Hashfunktion eingesetzt. Zum einen um die Korrektheit der Übertragung zu überprüfen und zum Anderen um ein Passwort zur Authentifizierung verwenden zu können. Dieses wird als Wort übertragen, auf dem Server aber nur als Hash-Wert abgespeichert. Falls es also jemand schafft die Konfirgurationsdatei abzugreifen, so ist der Passworthash nichts wert. 

