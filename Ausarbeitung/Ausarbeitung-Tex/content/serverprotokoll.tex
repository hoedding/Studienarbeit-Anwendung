


\subsection{Protokoll}
Um die LEDs später von einer App aus ansprechen zu können, soll ein auf Strings basierendes Protokoll implementiert werden. Hierfür muss als erstes festgelegt werden, welche Informationen übertragen werden sollen: 
\begin{itemize}
\item Authentifizierung\\
Übertragung eines Benutzers und eines Passworts. Das Passwort ist als Hashwert im System gespeichert und kann so überprüft werden. Zum Hashen wird der SHA-224-Algorithmus eingesetzt.
\item Control\\
Unterscheidung zwischen:\\
- X00: Alle LEDs ausschalten\\
- X01: Eine LED anschalten\\
- X02: LED-Bereich anschalten\\
- X03: Alle LEDs in einer Farbe anschalten\\
- X04: Effekte\\
- X05: Modus des Systems verändern\\ 
- X06: Anforderung des Systemstatus\\
- X07: Anforderung des LED-Status\\
- X08: Konfiguration ändern\\
- X09: Login überprüfen\\
         
Abhängig von diesem Feld werden die nachfolgenden Werte behandelt.
\item LED-Nummer\\
Falls nur eine LED angesprochen werden soll (Control = X00), so wird hier die Nummer angegeben. Ob sie im gültigen Range liegt wird intern überprüft.
\item Bereich Start\\
Wenn mehrere LEDs gesteuert werden sollen (Control = X01), so wird hier der Beginn des Bereichs angegeben.
\item Bereich Ende\\
Und hier das Ende des Bereichs.
\item Rot\\
Farbwert Rot 0-255
\item Grün\\
Farbwert Grün 0-255
\item Blau\\
Farbwert Blau 0-255
\item Modus\\
An dieser Stelle werden die verschiedenen Modi des Systems dargestellt.
\item Effektcode\\
Hinterlegte, fest programmierte Effekte, zum Beispiel alle LEDs anschalten in weis mit höchster Leuchstärke.
\item Konfiguration\\
Damit können einzelne Elemente der Serverkonfiguration verändert werden. Zum Beispiel die Leuchtdauer der LEDs, wenn sie durch den Bewegunsmelder ausgelöst wurden. 
\item Hash\\
Überprüfung ob die Übertragung erfolgreich war, mittels eines Hashwertes. Es wird der SHA-224-Algorithmus eingesetzt.
\end{itemize}
\textbf{Übertragungsbeispiel:}\\
\begin{lstlisting}[caption = Beispielübertragung des Protokolls, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b]
auth:pw:control:ledNo:rangeStart:rangeEnd:red:green:blue:modus:effectcode:config:hash
user:password:X01:0:0:49:255:255:255:::Hashvalue
\end{lstlisting}
Dies würde die LEDs 0 bis 49 einschalten (Farbe weis 255,255,255). Anstelle des 'Hashvalue' würde der Hashwert der gesamten Übertragung gesendet.

\subsection{Server-Framework}
Twisted: https://twistedmatrix.com \\
Es wird das Twisted Matrix Framework eingesetzt. Twisted ist eine in Python geschriebene event-getriebene Netzwerkengine. Die meisten gängigen Protokolle wie TCP, IMAP, SSHv3 und viele mehr werden unterstützt. Somit bietet Twisted die ideale Möglichkeit einen eigenen simplen Server zu implementieren. \\\\
\textbf{Event-Getrieben (event-based):} Die Serveranwendung befindet sich in einer Schleife und wartet auf ein Event. Dieses Event ist in diesem Fall der Connect eines Clients zum Server. Für jeden Connect wird eine neue Instanz angelegt, in welcher empfangene Daten bearbeitet werden können. Die Daten werden als String ausgewertet.

\subsection{Beispielimplementierung Webserver}
Im Folgenden wird die grundlegende Implementierung eines Webservers mit Twisted gezeigt. Für die einzelnen Funktionen des HTTP-Protokolls werden Methoden deklariert. In diesem Fall wird noch ein SSL-Kontext erzeugt, welcher die Zertifikate einliest und validiert und dafür sorgt, dass die Übertragung verschlüsselt wird.

\begin{lstlisting}[caption =Testcode Echoserver mit Twisted Framework, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b, numbers = left]
from twisted.web.server import Site
from twisted.web.resource import Resource
from twisted.internet import reactor
import cgi
from twisted.internet.protocol import Factory, Protocol
from twisted.internet import reactor

class Webserver(Resource):
  def render_POST(self, request):
	print cgi.escape(request.args["data"][0]))

  def render_GET(self, request):
	print cgi.escape(request.args["data"][0]))

root = Resource()
root.putChild("serv", Webserver())
factory = Site(root)
 sslContext = ssl.DefaultOpenSSLContextFactory(
     './certs/server.key', './certs/server.crt'
)
reactor.listenSSL(8000, factory, contextFactory = sslContext)
\end{lstlisting}




\subsection{Implementierung Webserver}
Der Server wird in einem neuen Thread gestartet, damit er beim Empfang von Daten keine anderen Abläufe aufhält. Zusätzich wird ihm eine Instanz der Klasse "RecvdData" übergeben. Diese verarbeitet die empfangene Nachricht. 
Anhand der ":" werden die empfangenen Daten gesplittet und in ein Array abgelegt. Zur besseren Verständlichkeit werden die Werte in einzelne Variablen gespeichert. \\
Im Anschluss wird das Übertragene Passwort und die Korrektheit der Daten überprüft. Falls beides Korrekt ist, so werden die Daten anhand ihres "Control"-Feldes ausgewertet. \\
Bevor tatsächlich LEDs angesteuert werden, wird überprüft ob die Farbwert im gültigen Bereich (0-255) liegen und ob die Angabe der LED-Nummer korrekt ist.\\

\begin{lstlisting}[caption =Implementierung des Webservers in Python, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b, numbers = left]
#!/usr/bin/python
# -*- coding: utf-8 -*-
################################################
# Author: Timo Höting       				   #
# Mail: mail[at]timohoeting.de  			   #
################################################

from twisted.web.server import Site
from twisted.web.resource import Resource
from twisted.internet import reactor
import cgi
from twisted.internet.protocol import Factory, Protocol
from twisted.internet import reactor
import hashlib
from ConfigReader import *
import threading
from twisted.internet import reactor, ssl

class LightServer(Resource):
  def render_POST(self, request):
    message = datamanager.dataReceived(cgi.escape(request.args["data"][0]))
    if (message != ""):
        return message

class StartLightServer(threading.Thread):
  def __init__(self, d):
     threading.Thread.__init__(self)
     global datamanager
     datamanager = d

  def run(self):
     root = Resource()
     root.putChild("serv", LightServer())
     factory = Site(root)
     sslContext = ssl.DefaultOpenSSLContextFactory(
         './certs/server.key', './certs/server.crt'
     )
     reactor.listenSSL(8000, factory, contextFactory = sslContext)
     #reactor.listenTCP(8000, factory)
     reactor.run(installSignalHandlers=False)
\end{lstlisting}

\begin{lstlisting}[caption =Implementierung des Nachrichten-Verarbeitung in Python, language=python, frame=single, breaklines=true,columns=fullflexible, commentstyle=\color{gray}\upshape, captionpos=b, numbers = left]
#!/usr/bin/python
# -*- coding: utf-8 -*-
################################################
# Author: Timo Höting       				   #
# Mail: mail[at]timohoeting.de  			   #
################################################

import hashlib
from ConfigReader import *
import threading

class RecvdData(threading.Thread):
    def __init__(self, c):
        threading.Thread.__init__(self)
        global center
        center = c

    def dataReceived(self, data):
        # Protokoll: auth:pw:control:ledNo:rangeStart:rangeEnd:red:green:blue:modus:effectcode:config:hashv
        # Beispiel: admin:w:X00:1:0:0:10:10:10:0:0:w-w:58acb7acccce58ffa8b953b12b5a7702bd42dae441c1ad85057fa70b
        # Ermoeglicht Zuweisung von Farben und Effekten
        # Ermöglicht Abruf von aktuellem Status des Systems und der LEDs
        #
        # Ankommende String bei ":" aufsplitten und in Array a[] Speichern:
        a = data.split(':')
        print a
        if len(a) > 1:
            auth = 		a[0]
            pw = 		a[1]
            control = 	a[2]
            ledNo = 	a[3]
            rangeStart = a[4]
            rangeEnd = 	a[5]
            red = 		a[6]
            green = 	a[7]
            blue = 		a[8]
            modus = 	a[9]
            effectcode = a[10]
            config = a[11]
            hashv = a[12]
            data = auth + pw + control + ledNo + rangeStart + rangeEnd + red + green + blue + modus + effectcode + config
            data = data.rstrip('\n')
            data = data.rstrip('\r')
            if (self.checkAuthentification(auth, pw) & self.checkTransmissionData(data, hashv)):
                if control == 'X00':
                    ## Alle LEDs ausschalten
                    center.clearPixel()
                elif control == 'X01':
                    ## Eine LED anschalten
                    self.lightUpOneLED(int(ledNo), int(red), int(green), int(blue))
                elif control == 'X02':
                    ## LED Bereich anschalten
                    self.lightUpLEDRange(int(rangeStart), int(rangeEnd), int(red), int(green), int(blue))
                elif control == 'X03':
                    ## Eine Farbe für alle LED
                    self.lightUpAllLED(int(red), int(green), int(blue))
                elif control == 'X04':
                    ## Effekt alle LEDs
                    self.effectLED(effectcode)
                elif control == 'X05':
                    ## Modus des Systems
                    self.changeModus(int(modus))
                elif control == 'X06':
                    ## Systemstatus als JSON an den Client
                    return self.sendStatus()
                elif control == 'X07':
                    ## Status der einzelnen LEDs senden
                    return self.sendLEDStatus()
                elif control == 'X08':
                    ## Konfiguration ändern
                    self.changeConfiguration(config)
                elif control == 'X09':
                    ## Login
                    return "LOGIN:TRUE"
            else:
                print center.writeLog('Übertragung fehlerhaft')

    def changeModus(self, modus):
        if modus >= 0 & modus < 4:
            center.setModus(modus)

    def lightUpOneLED(self, ledNo, red, green, blue):
        # Eine einzelne LED mit den o.g. RGB-Werten dauerhaft anschalten
        a = self.checkColorRange(red)
        b = self.checkColorRange(green)
        c = self.checkColorRange(blue)
        d = self.checkRange(ledNo)
        if ( a & b & c & d):
            center.lightUpOneLED(ledNo, red, green, blue)

    def lightUpLEDRange(self, rangeStart, rangeEnd, red, green, blue):
        # Einen Bereich von LEDs mit den o.g. RGB-Werten
        # dauerhaft einschalten
        # Bereich muss ueberprueft werden mit checkRange()
        a = self.checkColorRange(red)
        b = self.checkColorRange(green)
        c = self.checkColorRange(blue)
        d = self.checkRange(rangeStart)
        e = self.checkRange(rangeEnd)
        if ( a & b & c & d & e):
            center.rangePixel(rangeStart, rangeEnd, red, green, blue)

    def lightUpAllLED(self, red, green, blue):
        # Alle LEDs mit den o.g. RGB-Werten
        # dauerhaft einschalten
        # Bereich muss ueberprueft werden mit checkRange()
        a = self.checkColorRange(red)
        b = self.checkColorRange(green)
        c = self.checkColorRange(blue)
        if ( a & b & c):
            center.lightUpAllLED(red, green, blue)

    def effectLED(self, code):
        # Effekte auf einer LED aktivieren
        center.effectLED(code)

    def checkRange(self, ledNo):
        # Ueberprueft ob die uebergeben LED-Nummer ueberhaupt im
        # gueltigen Bereich liegt
        # Es wird der Eintrag 'number' aus dem Config-File geladen
        reader = ConfigReader()
        number = int(reader.getNumberOfLED())
        if ( ledNo >= 0 & ledNo < number):
            return True
        else:
            return False

    def checkColorRange(self, color):
        # Überprüfung ob Farbwert im gültigen Bereich liegt
        if (color >= 0 & color <= 255):
            return True
        return False

    def checkAuthentification(self, auth, pw):
        # TODO
        # Authentifizierung überprüfen
        # Eingabewert ist das Passwort aus der Übertragung
        # Dieses wird gehasht und mit dem in der Konfiguration gespeicherten
        # Hashwert verglichen
        reader = ConfigReader()
        hashv = reader.getHashPass()
        pw = hashlib.sha224(auth).hexdigest()
        if ( pw == hashv ):
            return True
        return False

    def checkTransmissionData(self, data, check):
        # Korrektheit der Übertragung mittels Hashvergleich feststellen
        # Eingabewert sind die gesamten Daten der Übertragung
        hashdata = hashlib.sha224(data).hexdigest()
        check = check.rstrip('\n')
        check = check.rstrip('\r')
        if ( hashdata == check ):
            return True
        # TODO Für Testübertragung return immer True
        return True

    def sendStatus(self):
        # Status des Systems senden
        reader = ConfigReader()
        message = 'STATUS:{"ledcount":"' + reader.getNumberOfLED() + '","motionport1":"' + reader.getMotionPin1() + '","motionport2":"' + reader.getMotionPin2() + '","ftp_url":"' + reader.getFTP() + '","camavaible":"'
        message = message + reader.camAvaible() + '","cam_url":"' + reader.camURL() + '","cam_url_short":"' + reader.camShortURL() + '","timeperiod":"' + reader.getTimePeriod() + '"}'
        print message
        return str(message)

    def sendLEDStatus(self):
        # Farbwerte aller einzelnen LEDs senden
        ledstatus = center.getLEDStatusAsJson()
        return ledstatus

    def changeConfiguration(self, config):
        b = config.split('--')
        key = b[0]
        value = b[1]
        center.changeConfiguration(key, value)
\end{lstlisting}

\subsection{Hashfunktion}
Es wird zu zweierlei Zwecken eine Hashfunktion eingesetzt. Zum einen um die Korrektheit der Übertragung zu überprüfen und zum Anderen um ein Passwort zur Authentifizierung verwenden zu können. Dieses wird als Wort übertragen, auf dem Server aber nur als Hash-Wert abgespeichert. Falls es also jemand schafft die Konfirgurationsdatei abzugreifen, so ist der Passworthash nichts wert.\\\\
\textbf{Hash-Funktion:} Eine Hashfunktion ist eine Einwegfunktion die aus einer großen Eingabemenge, eine kleinere Zielmenge generiert.  Die Ausgabe muss für die selbe Eingabe immer gleich sein. Jedoch soll bei der kleinsten Änderung der Eingabe, eine möglichst große Veränderung in der Ausgabe auftreten.
